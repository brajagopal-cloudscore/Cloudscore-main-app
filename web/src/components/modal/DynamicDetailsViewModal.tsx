import React from "react";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogHeader,
} from "@/components/ui/dialog";
import { CircleX, Loader } from "lucide-react";
import {
  AiOutlineFilePdf,
  AiOutlineFileText,
  AiOutlineFileZip,
} from "react-icons/ai";
import { BsCheckCircleFill } from "react-icons/bs";
import { formatDateTime } from "@/lib/utils/dateTime";

// Generic field configuration interface
interface FieldConfig {
  key: string;
  label: string;
  type?:
  | "text"
  | "badge"
  | "list"
  | "expandableList"
  | "dateRange"
  | "files"
  | "custom"
  | "date"
  | "textarea"
  | "datetime"
  | "boolean";
  render?: (value: any, data: any) => React.ReactNode;
  badgeColor?: string;
  maxItems?: number;
  listItemRenderer?: (item: any) => string;
  showIfEmpty?: boolean;
  required?: boolean;
  description?: any;
  badgeColors?: any;
}

// Generic modal props interface
interface DynamicDetailsViewModalProps<T = any> {
  isOpen: boolean;
  onClose: () => void;
  data: T | null;
  title: string;
  fields: FieldConfig[];
  className?: string;
}

export const createFieldConfig = {
  // AI Models Fields
  aiModel: (): FieldConfig[] => [
    { key: "model_name", label: "Model Name", type: "text" },
    { key: "model_id", label: "Model ID", type: "text" },
    { key: "model_owner", label: "Owner", type: "text" },
    { key: "business_unit", label: "Business Unit", type: "text" },
    { key: "model_type", label: "Type", type: "text" },
    { key: "model_version", label: "Version", type: "text" },
    { key: "model_source", label: "Source", type: "text" },
  ],

  // Model Registry Fields
  llmModel: (): FieldConfig[] => [
    { key: "vendor_name", label: "Vendor Name", type: "text" },
    { key: "model_name", label: "Model Name", type: "text" },
    { key: "version", label: "Version", type: "text" },
  ],

  // Project Fields
  application: (): FieldConfig[] => [
    { key: "name", label: "Application Name", type: "text" }
  ],

  // Business Context Fields
  businessContext: (): FieldConfig[] => [
    { key: "business_use_case", label: "Business Use Case", type: "text" },
    {
      key: "business_impact",
      label: "Business Impact",
      type: "custom",
      render: (value) => {
        return <div>{value}</div>;
      },
    },
    {
      key: "business_justification",
      label: "Business Justification",
      type: "text",
    },
    { key: "department", label: "Department", type: "text" },
  ],

  useCase: (): FieldConfig[] => [
    {
      key: "sFunction",
      label: "Function",
      type: "text",
      required: true,
      description: "Use Case category",
    },
    {
      key: "sUseCase",
      label: "Use Case",
      type: "text",
      required: true,
      description: "Specific use case within the function",
    },
    {
      key: "sWhatItDoes",
      label: "What It Does",
      type: "textarea",
      required: true,
      description: "Detailed description of what this function does",
    },
    {
      key: "aAgentPatterns",
      label: "AI System Types",
      type: "list",
      required: false,
      description: "AI agent interaction patterns",
    },
    {
      key: "aKeyInputs",
      label: "Key Inputs",
      type: "list",
      required: true,
      description: "Primary inputs required for this function",
    },
    {
      key: "aPrimaryOutputs",
      label: "Primary Outputs",
      type: "list",
      required: true,
      description: "Main outputs generated by this function",
    },
    {
      key: "aBusinessImpact",
      label: "Business Impact",
      type: "list",
      required: true,
      description: "Expected business impact and benefits",
    },
    {
      key: "aKPIs",
      label: "KPIs",
      type: "list",
      required: true,
      description: "Key performance indicators for measuring success",
    },
    {
      key: "aLinkedRisks",
      label: "Linked Risks",
      type: "custom",
      required: false,
      description: "Associated risks and their details",
      render: (value) => {
        if (!value || value.length === 0) {
          return <span className="text-gray-500 italic">No risks linked</span>;
        }
        return (
          <div className="space-y-3">
            {value.map((risk: any, idx: number) => (
              <div
                key={idx}
                className="p-3 border border-gray-200 rounded-lg bg-gray-50"
              >
                <div className="grid grid-cols-1 gap-2 text-sm">
                  <div className="flex items-center gap-2">
                    <span className="font-medium text-gray-700">
                      Risk Name:
                    </span>
                    {risk.sRiskName}
                  </div>

                  {risk.sDescription && (
                    <div className="flex items-start gap-2">
                      <span className="font-medium text-gray-700 flex-shrink-0">
                        Description:
                      </span>
                      <span className="text-gray-600">{risk.sDescription}</span>
                    </div>
                  )}

                  <div className="grid grid-cols-2 gap-4">
                    <div className="flex items-center gap-2">
                      <span className="font-medium text-gray-700">Owner:</span>
                      <span className="text-gray-600">{risk.sOwner}</span>
                    </div>

                    <div className="flex items-center gap-2">
                      <span className="font-medium text-gray-700">
                        Severity:
                      </span>
                      <Badge
                        color={
                          risk.eSeverity === "High"
                            ? "red"
                            : risk.eSeverity === "Moderate"
                              ? "orange"
                              : "yellow"
                        }
                      >
                        {risk.eSeverity}
                      </Badge>
                    </div>

                    <div className="flex items-center gap-2">
                      <span className="font-medium text-gray-700">
                        Likelihood:
                      </span>
                      <Badge
                        color={
                          risk.eLikelihood === "Likely"
                            ? "red"
                            : risk.eLikelihood === "Possible"
                              ? "orange"
                              : "yellow"
                        }
                      >
                        {risk.eLikelihood}
                      </Badge>
                    </div>

                    <div className="flex items-center gap-2">
                      <span className="font-medium text-gray-700">
                        Risk Level:
                      </span>
                      <Badge
                        color={
                          risk.eRiskLevel === "High Risk"
                            ? "red"
                            : risk.eRiskLevel === "Medium Risk"
                              ? "orange"
                              : "green"
                        }
                      >
                        {risk.eRiskLevel}
                      </Badge>
                    </div>

                    <div className="flex items-center gap-2">
                      <span className="font-medium text-gray-700">Status:</span>
                      <Badge
                        color={
                          risk.eMitigationStatus === "Completed"
                            ? "green"
                            : risk.eMitigationStatus === "In Progress"
                              ? "blue"
                              : "gray"
                        }
                      >
                        {risk.eMitigationStatus}
                      </Badge>
                    </div>

                    <div className="flex items-center gap-2">
                      <span className="font-medium text-gray-700">
                        Target Date:
                      </span>
                      <span className="text-gray-600">
                        {risk.dTargetDate
                          ? new Date(risk.dTargetDate).toLocaleDateString()
                          : "N/A"}
                      </span>
                    </div>
                  </div>

                  {risk.dLastRiskReviewDate && (
                    <div className="flex items-center gap-2 pt-1 border-t border-gray-200">
                      <span className="font-medium text-gray-700">
                        Last Review:
                      </span>
                      <span className="text-gray-600">
                        {new Date(
                          risk.dLastRiskReviewDate
                        ).toLocaleDateString()}
                      </span>
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        );
      },
    },
    {
      key: "dCreatedAt",
      label: "Created At",
      type: "custom",
      description: "When this use case was created",
      render: (value) => (value ? formatDateTime(value) : "N/A"),
    },
    {
      key: "dUpdatedAt",
      label: "Updated At",
      type: "custom",
      description: "When this use case was last updated",
      render: (value) => (value ? formatDateTime(value) : "N/A"),
    },
  ],

  // Regulatory Risk Fields
  regulatoryRisk: (): FieldConfig[] => [
    { key: "regulatory_impact", label: "Regulatory Impact", type: "text" },
    {
      key: "affected_regulations",
      label: "Affected Regulations",
      type: "list",
      badgeColor: "purple",
      listItemRenderer: (item) => item,
    },
    {
      key: "risk_classification",
      label: "Risk Classification",
      type: "custom",
      render: (value) => {
        return <div>{value}</div>;
      },
    },
    {
      key: "risk_assessment_completed",
      label: "Assessment Status",
      type: "custom",
      render: (value) => <div>{value ? "Completed" : "Pending"}</div>,
    },
    {
      key: "last_risk_review_date",
      label: "Last Review Date",
      type: "custom",
      render: (value) => (value ? formatDate(value) : "NA"),
    },
  ],
  risk: (): FieldConfig[] => [
    { key: "riskName", label: "Risk Name", type: "text", required: true },
    {
      key: "description",
      label: "Description",
      type: "textarea",
      showIfEmpty: true,
    },
    {
      key: "severity",
      label: "Severity",
      type: "badge",
      badgeColor: "orange",
      render: (value) => {
        if (!value) return <Badge color="gray">N/A</Badge>;
        const severity = value.toString().toLowerCase();
        const color =
          severity === "catastrophic"
            ? "red"
            : severity === "major"
              ? "orange"
              : severity === "moderate"
                ? "yellow"
                : "green";
        return <Badge color={color}>{value}</Badge>;
      },
    },
    {
      key: "likelihood",
      label: "Likelihood",
      type: "badge",
      badgeColor: "blue",
      render: (value) => {
        if (!value) return <Badge color="gray">N/A</Badge>;
        const likelihood = value.toString().toLowerCase();
        const color =
          likelihood === "likely"
            ? "red"
            : likelihood === "possible"
              ? "orange"
              : likelihood === "unlikely"
                ? "yellow"
                : "green";
        return <Badge color={color}>{value}</Badge>;
      },
    },
    {
      key: "riskLevel",
      label: "Risk Level",
      type: "badge",
      badgeColor: "red",
      render: (value) => {
        if (!value) return <Badge color="gray">N/A</Badge>;
        const level = value.toString().toLowerCase();
        const color =
          level === "high" ? "red" : level === "medium" ? "yellow" : "green";
        return <Badge color={color}>{value}</Badge>;
      },
    },
    {
      key: "mitigationStatus",
      label: "Mitigation Status",
      type: "badge",
      render: (value) => {
        if (!value) return <Badge color="gray">N/A</Badge>;
        const status = value.toString().toLowerCase();
        const color =
          status === "completed"
            ? "green"
            : status === "in progress"
              ? "blue"
              : status === "requires review"
                ? "orange"
                : "gray";
        return <Badge color={color}>{value}</Badge>;
      },
    },
    {
      key: "owner",
      label: "Owner",
      type: "custom",
      required: true,
      render: (value, data) => {
        // value is the owner ID (string) from getNestedValue(data, 'owner')
        // Check userNames mapping if available
        if (data?.userNames && value) {
          const name = data.userNames[value];
          if (name) {
            return name;
          }
        }
        // Fallback to the ID if no mapping or name not found
        return value || "N/A";
      },
    },
    {
      key: "controlOwner",
      label: "Control Owner",
      type: "custom",
      showIfEmpty: true,
      render: (value, data) => {
        if (!value) return "N/A";
        // value is the controlOwner ID (string) from getNestedValue(data, 'controlOwner')
        // Check userNames mapping if available
        if (data?.userNames && value) {
          const name = data.userNames[value];
          if (name) {
            return name;
          }
        }
        // Fallback to the ID if no mapping or name not found
        return value || "N/A";
      },
    },
    {
      key: "targetDate",
      label: "Review Date",
      type: "date",
      showIfEmpty: true,
    },
    {
      key: "mitigationPlan",
      label: "Mitigation Plan",
      type: "textarea",
      showIfEmpty: true,
    },
    {
      key: "createdAt",
      label: "Created At",
      type: "datetime",
      showIfEmpty: true,
    },
    {
      key: "updatedAt",
      label: "Updated At",
      type: "datetime",
      showIfEmpty: true,
    },
    {
      key: "createdBy",
      label: "Created By",
      type: "custom",
      showIfEmpty: true,
      render: (value, data) => {
        // First check if createdByUser object exists (from database join)
        if (data?.createdByUser) {
          return (
            data.createdByUser.name || data.createdByUser.email || "Unknown"
          );
        }
        // Otherwise, use userNames mapping if available
        if (data?.userNames && data?.createdBy) {
          return data.userNames[data.createdBy] || data.createdBy;
        }
        // Fallback to value or ID
        return value || "N/A";
      },
    },
    {
      key: "updatedBy",
      label: "Updated By",
      type: "custom",
      showIfEmpty: true,
      render: (value, data) => {
        // First check if updatedByUser object exists (from database join)
        if (data?.updatedByUser) {
          return (
            data.updatedByUser.name || data.updatedByUser.email || "Unknown"
          );
        }
        // Otherwise, use userNames mapping if available
        if (data?.userNames && data?.updatedBy) {
          return data.userNames[data.updatedBy] || data.updatedBy;
        }
        // Fallback to value or ID
        return value || "N/A";
      },
    },
  ],

  // Stakeholder Fields
  stakeholder: (): FieldConfig[] => [
    { key: "userName", label: "Name", type: "text" },
    { key: "role", label: "Role", type: "text" },
    { key: "email", label: "Email", type: "text", showIfEmpty: true },
    { key: "department", label: "Department", type: "text", showIfEmpty: true },
    {
      key: "responsibilities",
      label: "Responsibilities",
      type: "textarea",
      showIfEmpty: true,
    },
  ],
};

// Reusable components
const DetailRow: React.FC<{ label: string; children: React.ReactNode }> = ({
  label,
  children,
}) => (
  <div className="flex flex-row gap-4">
    <p className="w-[150px] text-muted-foreground leading-5 font-sans font-normal text-sm shrink-0">
      {label}
    </p>
    <div className="text-sm max-w-full max-h-[200px] overflow-y-auto pr-2">
      {children}
    </div>
  </div>
);

const ExpandableList: React.FC<{
  items: any[];
  maxItems: number;
  isExpanded: boolean;
  onExpand: () => void;
  renderItem: (item: any) => string;
}> = ({ items, maxItems, isExpanded, onExpand, renderItem }) => {
  if (!items || items.length === 0) return <span>--</span>;

  if (items.length <= maxItems || isExpanded) {
    return <div>{items.map(renderItem).join(", ")}</div>;
  }

  return (
    <div>
      {items.slice(0, maxItems).map(renderItem).join(", ")}
      {" ... "}
      <button
        onClick={(e) => {
          e.stopPropagation();
          onExpand();
        }}
        className="text-blue-800 hover:underline focus:outline-none"
      >
        Show more
      </button>
    </div>
  );
};

// Utility functions
const getFileIcon = (fileType: string) => {
  const type = fileType?.split(".").pop()?.toLowerCase();
  switch (type) {
    case "pdf":
      return <AiOutlineFilePdf className="text-gray-500" />;
    case "zip":
      return <AiOutlineFileZip className="text-yellow-500" />;
    default:
      return <AiOutlineFileText className="text-gray-500" />;
  }
};

const getFileStatusIcon = (status: string) => {
  switch (status) {
    case "inprogress":
      return <Loader size={16} className="animate-spin text-black text-base" />;
    case "failed":
      return <CircleX size={16} className="text-red-500 text-base" />;
    default:
      return (
        <BsCheckCircleFill className="text-black text-base" title="Uploaded" />
      );
  }
};

const formatDate = (dateString: string) => {
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return "Invalid Date";

    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const day = date.getUTCDate();
    const dateOnly = new Date(year, month, day);

    return dateOnly.toLocaleDateString(navigator.language || "en-US", {
      month: "long",
      day: "numeric",
      year: "numeric",
    });
  } catch (error) {
    return "Invalid Date";
  }
};

// Badge component with dynamic colors
export const Badge: React.FC<{ children: React.ReactNode; color?: string }> = ({
  children,
  color = "blue",
}) => {
  const colorClasses = {
    blue: "bg-blue-500/10 text-blue-500",
    green: "bg-green-500/10 text-green-500",
    red: "bg-red-500/10 text-red-500",
    yellow: "bg-yellow-500/10 text-yellow-500",
    orange: "bg-orange-500/10 text-orange-500",
    purple: "bg-purple-500/10 text-purple-500",
    gray: "bg-muted text-muted-foreground",
  };

  return (
    <span
      className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${colorClasses[color as keyof typeof colorClasses] || colorClasses.blue}`}
    >
      {children}
    </span>
  );
};

// Main Dynamic Details Modal Component
const DynamicDetailsViewModal = <T extends Record<string, any>>({
  isOpen,
  onClose,
  data,
  title,
  fields,
  className = " max-w-[700px] w-full max-h-[80vh] overflow-hidden flex flex-col",
}: DynamicDetailsViewModalProps<T>) => {
  const [expandedFields, setExpandedFields] = React.useState<
    Record<string, boolean>
  >({});

  React.useEffect(() => {
    if (!isOpen) {
      setExpandedFields({});
    }
  }, [isOpen]);

  const handleExpand = (fieldKey: string) => {
    setExpandedFields((prev) => ({
      ...prev,
      [fieldKey]: true,
    }));
  };

  const getNestedValue = (obj: any, path: string) => {
    return path.split(".").reduce((current, key) => current?.[key], obj);
  };

  const renderField = (field: FieldConfig) => {
    if (!data) return null;

    const value = getNestedValue(data, field.key);

    // Skip rendering if value is empty and showIfEmpty is false
    if (
      !field.showIfEmpty &&
      (value === undefined || value === null || value === "")
    ) {
      return null;
    }

    const fieldKey = field.key;

    switch (field.type) {
      case "badge":
        return (
          <DetailRow key={fieldKey} label={field.label}>
            <Badge color={field.badgeColor}>{value || "--"}</Badge>
          </DetailRow>
        );

      case "list":
        return (
          <DetailRow key={fieldKey} label={field.label}>
            <div className="flex flex-wrap gap-1">
              {value && value.length > 0 ? value.toString() : <span>--</span>}
            </div>
          </DetailRow>
        );

      case "expandableList":
        return (
          <DetailRow key={fieldKey} label={field.label}>
            <ExpandableList
              items={value || []}
              maxItems={field.maxItems || 3}
              isExpanded={expandedFields[fieldKey] || false}
              onExpand={() => handleExpand(fieldKey)}
              renderItem={
                field.listItemRenderer || ((item: any) => item.toString())
              }
            />
          </DetailRow>
        );

      case "dateRange":
        if (value && value.fromDate && value.toDate) {
          return (
            <DetailRow key={fieldKey} label={field.label}>
              {`${formatDate(value.fromDate)} to ${formatDate(value.toDate)}`}
            </DetailRow>
          );
        }
        return null;

      case "date":
        return (
          <DetailRow key={fieldKey} label={field.label}>
            {value ? new Date(value).toLocaleDateString() : "N/A"}
          </DetailRow>
        );

      case "datetime":
        return (
          <DetailRow key={fieldKey} label={field.label}>
            {value ? formatDateTime(value) : "N/A"}
          </DetailRow>
        );

      case "textarea":
        return (
          <DetailRow key={fieldKey} label={field.label}>
            {value ? (
              <div className="whitespace-pre-wrap max-h-[200px] overflow-y-auto">
                {value}
              </div>
            ) : (
              "N/A"
            )}
          </DetailRow>
        );

      case "files":
        return (
          <DetailRow key={fieldKey} label={field.label}>
            <div className="flex flex-col gap-1 max-h-[150px] overflow-y-auto pr-2 w-full">
              {value && value.length > 0 ? (
                value.map((file: any, idx: number) => (
                  <div
                    key={idx}
                    className="flex items-center gap-3 px-3 py-2 rounded-md border  hover:shadow-sm  transition-all group"
                    title={file.file_name}
                    style={{ minHeight: 36 }}
                  >
                    <span className="text-lg">
                      {getFileIcon(file.file_type)}
                    </span>
                    <span
                      className="truncate text-[13px] font-normal max-w-40 group-hover:max-w-none"
                      title={file.file_name}
                    >
                      {file.file_name}
                    </span>
                    <span className="ml-auto flex items-center">
                      {getFileStatusIcon(file.status || "completed")}
                    </span>
                  </div>
                ))
              ) : (
                <span>No files</span>
              )}
            </div>
          </DetailRow>
        );

      case "custom":
        return field.render ? (
          <DetailRow key={fieldKey} label={field.label}>
            {field.render(value, data)}
          </DetailRow>
        ) : null;

      case "boolean":
        return (
          <DetailRow key={fieldKey} label={field.label}>
            {value === true ? (
              <Badge color="green">Active</Badge>
            ) : value === false ? (
              <Badge color="red">Inactive</Badge>
            ) : (
              "--"
            )}
          </DetailRow>
        );

      default:
        return (
          <DetailRow key={fieldKey} label={field.label}>
            {value || "--"}
          </DetailRow>
        );
    }
  };

  if (!data) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogTitle className="sr-only">{title}</DialogTitle>
      <DialogContent
        className={className}
        onPointerDownOutside={(e) => e.preventDefault()}
      >
        <DialogHeader>
          <h2 className=" font-semibold text-lg">{title}</h2>
        </DialogHeader>

        <div className=" font-medium text-sm leading-5 flex flex-col gap-2 pb-4 px-2 w-full overflow-y-auto">
          {fields.map(renderField).filter(Boolean)}
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default DynamicDetailsViewModal;
